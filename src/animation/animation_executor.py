"""Animation Executor - Generates CSS and JavaScript to execute animation plans."""
from __future__ import annotations

import json
import re
from typing import Any, Dict, List, Optional
from xml.etree import ElementTree as ET

from src.animation.animation_plan_schema import (
    AnimationPlanV2,
    ElementAnimation,
    AnimationType,
    EasingFunction,
)


def _strip_ns(tag: str) -> str:
    return tag.split("}")[-1] if "}" in tag else tag


def _escape_css_selector(selector: str) -> str:
    r"""Escape special characters in CSS selectors.
    
    CSS IDs cannot contain unescaped spaces WITHIN the ID name.
    Example: #My ID -> #My\ ID
    
    Descendant selectors have spaces BETWEEN different elements:
    Example: #parent rect (ID followed by element name)
    
    We need to distinguish:
    - #My ID with spaces (ESCAPE IT)
    - #parent rect (descendant selector, DON'T ESCAPE)
    """
    if not selector.startswith('#'):
        return selector
    
    # Check if this looks like a descendant selector
    # Pattern: #id followed by space and then an element name (rect, text, path, etc.)
    if re.match(r'^#[\w-]+\s+(rect|text|path|line|circle|ellipse|polygon|g)$', selector, re.IGNORECASE):
        # This is a descendant selector like "#ent0003 rect", don't escape
        return selector
    
    # This is an ID selector with spaces in the ID itself, escape them
    if ' ' in selector:
        id_part = selector[1:]  # Remove #
        escaped_id = id_part.replace(' ', '\\ ')
        return '#' + escaped_id
    
    return selector


def _generate_keyframe_css(name: str, keyframes: List[Dict[str, Any]]) -> str:
    """Generate CSS @keyframes rule from keyframe list."""
    lines = [f"@keyframes {name} {{"]
    for kf in keyframes:
        offset = kf.get("offset", 0) * 100
        props = kf.get("properties", {})
        prop_str = "; ".join(f"{k}: {v}" for k, v in props.items())
        lines.append(f"  {offset:.0f}% {{ {prop_str}; }}")
    lines.append("}")
    return "\n".join(lines)


def _element_to_css(elem: ElementAnimation, keyframe_name: str) -> str:
    """Generate CSS animation rule for an element."""
    iterations = "infinite" if elem.iterations == -1 else str(elem.iterations)
    escaped_selector = _escape_css_selector(elem.selector)
    return (
        f"{escaped_selector} {{ "
        f"animation: {keyframe_name} {elem.duration}s {elem.easing.value} "
        f"{elem.delay}s {iterations} {elem.direction} {elem.fill_mode}; "
        f"}}"
    )


def generate_animation_css(plan: AnimationPlanV2) -> str:
    """
    Generate CSS for all animations in the plan.
    
    Returns CSS string to be injected into SVG <style> element.
    """
    css_parts = []
    keyframe_counter = 0
    
    # Add global styles
    css_parts.append("/* Animation styles generated by Animation Executor */")
    css_parts.append(":root {")
    css_parts.append("  --anim-node-fill: #e2e8f0;")
    css_parts.append("  --anim-node-stroke: #475569;")
    css_parts.append("  --anim-node-highlight-fill: #fef3c7;")
    css_parts.append("  --anim-node-highlight-stroke: #f59e0b;")
    css_parts.append("  --anim-edge-stroke: #64748b;")
    css_parts.append("  --anim-edge-active: #38bdf8;")
    css_parts.append("  --anim-text: #0f172a;")
    css_parts.append("  --anim-font: system-ui;")
    css_parts.append("  --anim-font-weight: 500;")
    css_parts.append("}")
    css_parts.append("")
    
    # Add reduced motion media query support
    css_parts.append("@media (prefers-reduced-motion: reduce) {")
    css_parts.append("  * { animation: none !important; transition: none !important; }")
    css_parts.append("}")
    css_parts.append("")
    
    # Generate keyframes and rules for each sequence
    for seq in plan.sequences:
        css_parts.append(f"/* Sequence: {seq.name} */")
        
        for elem in seq.elements:
            keyframe_name = f"anim_{plan.svg_id}_{keyframe_counter}"
            keyframe_counter += 1
            
            # Generate keyframes from element configuration
            if elem.keyframes:
                keyframes = [{"offset": kf.offset, "properties": kf.properties} for kf in elem.keyframes]
            else:
                # Default keyframes based on animation type
                keyframes = _default_keyframes_for_type(elem.animation_type)
            
            escaped_selector = _escape_css_selector(elem.selector)

            # Apply default colors for animated elements
            if elem.element_type in ("node", "label"):
                if elem.animation_type in (AnimationType.GLOW, AnimationType.HIGHLIGHT):
                    css_parts.append(
                        f"{escaped_selector} {{ fill: var(--anim-node-highlight-fill); stroke: var(--anim-node-highlight-stroke); }}"
                    )
                else:
                    css_parts.append(
                        f"{escaped_selector} {{ fill: var(--anim-node-fill); stroke: var(--anim-node-stroke); }}"
                    )
            elif elem.element_type == "edge":
                edge_color = "var(--anim-edge-active)" if elem.animation_type in (AnimationType.FLOW, AnimationType.DRAW, AnimationType.HIGHLIGHT) else "var(--anim-edge-stroke)"
                css_parts.append(f"{escaped_selector} {{ stroke: {edge_color}; }}")
            elif elem.element_type == "text":
                css_parts.append(
                    f"{escaped_selector} {{ fill: var(--anim-text); font-family: var(--anim-font); font-weight: var(--anim-font-weight); }}"
                )

            css_parts.append(_generate_keyframe_css(keyframe_name, keyframes))
            css_parts.append(_element_to_css(elem, keyframe_name))
            css_parts.append("")
    
    return "\n".join(css_parts)


def _default_keyframes_for_type(anim_type: AnimationType) -> List[Dict[str, Any]]:
    """Get default keyframes for an animation type."""
    defaults = {
        AnimationType.PULSE: [
            {"offset": 0.0, "properties": {"opacity": "0.5"}},
            {"offset": 0.5, "properties": {"opacity": "1"}},
            {"offset": 1.0, "properties": {"opacity": "0.5"}},
        ],
        AnimationType.GLOW: [
            {"offset": 0.0, "properties": {"filter": "drop-shadow(0 0 0px rgba(96, 165, 250, 0))"}},
            {"offset": 0.5, "properties": {"filter": "drop-shadow(0 0 8px rgba(96, 165, 250, 0.8))"}},
            {"offset": 1.0, "properties": {"filter": "drop-shadow(0 0 0px rgba(96, 165, 250, 0))"}},
        ],
        AnimationType.FLOW: [
            # Animate stroke-dashoffset to create flowing/marching ants effect
            # dasharray of 10 5 = 15px pattern, so animate offset by pattern multiple
            {"offset": 0.0, "properties": {"stroke-dashoffset": "30"}},
            {"offset": 1.0, "properties": {"stroke-dashoffset": "0"}},
        ],
        AnimationType.FADE_IN: [
            {"offset": 0.0, "properties": {"opacity": "0"}},
            {"offset": 1.0, "properties": {"opacity": "1"}},
        ],
        AnimationType.HIGHLIGHT: [
            {"offset": 0.0, "properties": {"opacity": "0.4"}},
            {"offset": 0.5, "properties": {"opacity": "0.8"}},
            {"offset": 1.0, "properties": {"opacity": "0.4"}},
        ],
        AnimationType.SCALE: [
            {"offset": 0.0, "properties": {"transform": "scale(1)"}},
            {"offset": 0.5, "properties": {"transform": "scale(1.05)"}},
            {"offset": 1.0, "properties": {"transform": "scale(1)"}},
        ],
        AnimationType.DRAW: [
            {"offset": 0.0, "properties": {"stroke-dashoffset": "1000"}},
            {"offset": 1.0, "properties": {"stroke-dashoffset": "0"}},
        ],
        AnimationType.WAVE: [
            {"offset": 0.0, "properties": {"transform": "translateY(0)"}},
            {"offset": 0.25, "properties": {"transform": "translateY(-3px)"}},
            {"offset": 0.5, "properties": {"transform": "translateY(0)"}},
            {"offset": 0.75, "properties": {"transform": "translateY(3px)"}},
            {"offset": 1.0, "properties": {"transform": "translateY(0)"}},
        ],
    }
    return defaults.get(anim_type, defaults[AnimationType.PULSE])


def generate_animation_js(plan: AnimationPlanV2) -> str:
    """
    Generate JavaScript for Web Animations API execution.
    
    This provides more control and can be used for complex animations
    or when CSS animations are insufficient.
    """
    js_parts = []
    
    js_parts.append("(function() {")
    js_parts.append("  'use strict';")
    js_parts.append("")
    js_parts.append("  // Check for reduced motion preference")
    js_parts.append("  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;")
    js_parts.append("  if (prefersReducedMotion) { console.log('Animations disabled: reduced motion preferred'); return; }")
    js_parts.append("")
    js_parts.append(f"  // Animation Plan: {plan.plan_id}")
    js_parts.append(f"  // Style: {plan.style}")
    js_parts.append("")
    js_parts.append("  const animations = [];")
    js_parts.append("")
    
    for seq in plan.sequences:
        js_parts.append(f"  // Sequence: {seq.name}")
        for elem in seq.elements:
            selector = elem.selector
            
            # Generate keyframes
            if elem.keyframes:
                keyframes = [{"offset": kf.offset, **kf.properties} for kf in elem.keyframes]
            else:
                keyframes = _default_keyframes_for_type(elem.animation_type)
                keyframes = [{"offset": kf["offset"], **kf["properties"]} for kf in keyframes]
            
            keyframes_json = json.dumps(keyframes)
            
            # Generate animation options
            iterations = "Infinity" if elem.iterations == -1 else str(elem.iterations)
            options = {
                "duration": elem.duration * 1000,  # Convert to ms
                "delay": elem.delay * 1000,
                "iterations": iterations,
                "direction": elem.direction,
                "easing": elem.easing.value,
                "fill": elem.fill_mode,
            }
            
            js_parts.append(f"  try {{")
            js_parts.append(f"    const el = document.querySelector('{selector}');")
            js_parts.append(f"    if (el) {{")
            js_parts.append(f"      const keyframes = {keyframes_json};")
            js_parts.append(f"      const options = {{ duration: {options['duration']}, delay: {options['delay']}, iterations: {iterations}, direction: '{options['direction']}', easing: '{options['easing']}', fill: '{options['fill']}' }};")
            js_parts.append(f"      const anim = el.animate(keyframes, options);")
            js_parts.append(f"      animations.push(anim);")
            js_parts.append(f"    }}")
            js_parts.append(f"  }} catch (e) {{ console.warn('Animation failed for {selector}:', e); }}")
            js_parts.append("")
    
    js_parts.append("  // Store animations for external control")
    js_parts.append("  window.__svgAnimations = window.__svgAnimations || {};")
    js_parts.append(f"  window.__svgAnimations['{plan.svg_id}'] = animations;")
    js_parts.append("")
    js_parts.append("  console.log(`Initialized ${animations.length} animations for " + plan.svg_id + "`);")
    js_parts.append("})();")
    
    return "\n".join(js_parts)


def inject_animation(
    svg_text: str, 
    plan: AnimationPlanV2, 
    use_js: bool = False
) -> str:
    """
    Inject animation CSS (and optionally JS) into SVG.
    
    Args:
        svg_text: Original SVG content
        plan: Animation plan to execute
        use_js: If True, also inject JavaScript for Web Animations API
    
    Returns:
        SVG with animation CSS/JS injected
    """
    ET.register_namespace("", "http://www.w3.org/2000/svg")
    root = ET.fromstring(svg_text)
    
    # Find or create style element
    style_el = None
    for el in root.iter():
        if _strip_ns(el.tag) == "style":
            style_el = el
            break
    
    if style_el is None:
        style_el = ET.Element("style")
        root.insert(0, style_el)
    
    # Add CSS animations
    css = generate_animation_css(plan)
    existing_css = style_el.text or ""
    style_el.text = f"{existing_css}\n{css}\n"
    
    # Add stroke-dasharray to edges that need it
    for seq in plan.sequences:
        for elem in seq.elements:
            if elem.animation_type in (AnimationType.FLOW, AnimationType.DRAW):
                # Find the element and add stroke-dasharray if missing
                for svg_el in root.iter():
                    el_id = svg_el.get("id")
                    if el_id and f"#{el_id}" == elem.selector:
                        if not svg_el.get("stroke-dasharray"):
                            svg_el.set("stroke-dasharray", "10 5")
    
    # Optionally add JavaScript
    if use_js:
        script_el = ET.SubElement(root, "script")
        script_el.text = generate_animation_js(plan)
    
    return ET.tostring(root, encoding="unicode")


def create_animated_html(
    svg_text: str, 
    plan: AnimationPlanV2,
    title: str = "Animated SVG"
) -> str:
    """
    Create a complete HTML document with animated SVG.
    
    Useful for standalone viewing and testing.
    """
    animated_svg = inject_animation(svg_text, plan, use_js=True)
    
    return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        * {{ box-sizing: border-box; margin: 0; padding: 0; }}
        body {{
            background: #0f172a;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }}
        h1 {{
            color: #f8fafc;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }}
        .info {{
            color: #94a3b8;
            margin-bottom: 20px;
            font-size: 0.875rem;
        }}
        .svg-container {{
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 20px;
            max-width: 100%;
            overflow: auto;
        }}
        svg {{
            display: block;
            max-width: 100%;
            height: auto;
        }}
        .controls {{
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }}
        button {{
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
        }}
        button:hover {{
            background: #2563eb;
        }}
        .plan-info {{
            margin-top: 20px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 15px;
            max-width: 600px;
            color: #94a3b8;
            font-size: 0.75rem;
        }}
        .plan-info pre {{
            white-space: pre-wrap;
            word-break: break-all;
        }}
    </style>
</head>
<body>
    <h1>{title}</h1>
    <p class="info">Plan ID: {plan.plan_id} | Style: {plan.style} | Type: {plan.diagram_type}</p>
    
    <div class="svg-container">
        {animated_svg}
    </div>
    
    <div class="controls">
        <button onclick="pauseAnimations()">Pause</button>
        <button onclick="playAnimations()">Play</button>
        <button onclick="resetAnimations()">Reset</button>
    </div>
    
    <div class="plan-info">
        <strong>Animation Plan:</strong>
        <pre>{plan.description}</pre>
    </div>
    
    <script>
        function pauseAnimations() {{
            const anims = window.__svgAnimations && window.__svgAnimations['{plan.svg_id}'];
            if (anims) anims.forEach(a => a.pause());
        }}
        
        function playAnimations() {{
            const anims = window.__svgAnimations && window.__svgAnimations['{plan.svg_id}'];
            if (anims) anims.forEach(a => a.play());
        }}
        
        function resetAnimations() {{
            const anims = window.__svgAnimations && window.__svgAnimations['{plan.svg_id}'];
            if (anims) {{
                anims.forEach(a => {{
                    a.currentTime = 0;
                    a.play();
                }});
            }}
        }}
    </script>
</body>
</html>"""
